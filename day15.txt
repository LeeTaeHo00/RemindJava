복습 -> 접근제한자 -> 캐스팅 -> 추상클래스 *******

0. 복습
1) 상속
	extends 키워드 사용
	클래스 확장
	class 자식클래스명 extends 부모클래스명
	{
		// 부모멤버, 자식멤버
	}
	단일상속만 있다.

2) 생성자
	super();	부모의 생성자
	기본생성자 -> 매개변수 없는 생성자, 초기화는 가능함
	super() 모든 클래스의 최상위 부모클래스 Object 클래스의 기본 생성자
	상속 관계에서는 해당 부모 클래스의 생성자
	매개변수를 통해 객체 생성시 원하는 값으로 초기화하기 위해 사용하는 생성자
	다양한 초기화 옵션(생성자 오버로딩)

3) 다형성 : 하나의 것이 여러가지 형태를 가질 수 있는 성질
	오버로딩 : 메소드, 생성자) 매개변수의 개수 순서 타입이 다르면 같은 이름으로 선언
	오버라이딩 : 메소드) 상속관계에서 자식클래스에서 부모클래스에 있는 메소드를 재정의함
	참조변수의 다형성(매개변수의 다형성) -> 캐스팅

4) this, this(), super, super()
	this : 객체 자기자신
	this() : 자신의 생성자
	super : 부모의 참조값
	super() : 부모 클래스의 생성자


5) 접근 제한자
	제한자		제한대상			제한범위
	public		클래스, 필드, 생성자, 메소드	없음
	protected	필드, 생성자, 메소드		같은 패키지거나 상속관계
	default		클래스, 필드, 생성자, 메소드	같은 패키지
	private		필드, 생성자, 메소드		같은 클래스

================================================================

1. 접근 제한자
1) private 필드
	setter, getter 사용해야 한다.
	setter, getter 접근제한자는 public
	setter 메소드는 매개변수로 값을 저장만 해줄 것이기 때문에 리턴타입은 void
	메소드명 setter 에서 set을 따오고 + 필드 이름(첫글자는 대문자), 카멜표기법
	
	getter 메소드는 값을 외부로 리턴해줘야 하기 때문에 리턴타입은 필드의 타입으로 설정
	메소드명은 getter 에서 get을 따오고 + 필드이름(첫글자는 대문자), 카메표기법
	리턴값은 필드값

+) 객체의 필드를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있따.
	학생의 점수는 음수가 될 수 없는데 외부에서 음수로 변경하면 객체의 무결성이 깨질수 있따.
	객체지향 프로그래밍에서는 직접적인 외부에서의 필드 접근을 막고 대신 메소드를 통해 필드에 접근하도록 만들어져 있다.
	메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 때문이다.
	이역할을 하는것이 setter 메소드
	외부에서 객체의 필드를 읽을 때도 메소드가 필요한 경우가 있따/
	필드값이 객체 외부에서 사용하기 부적절한 경우 메소드로 적절한 값으로 변화하여 리턴할 수 있기 때문이다.
	이런 역할을 하는 것이 getter 메소드이다.
	= > 캡슐화 은닉화

2. final 클래스와 final 메소드
	final 최종을 의미하는 키워드
	final 클래스 : 최종적인 클래스이므로 더이상 상속할 수 없는 클래스
	부모클래스가 될 수 없으므로 자심 클래스를 만들 수 없다.
	대표적인 클래스 : String 클래스
	final 메소드 :최종적인 메소드이므로 오버라이딩을 할 수 없는 메소드가 된다.
	부모 클래스의 메소드에서 final을 사용하면 자식 클래스에서 재정의 할 수 없다.

3. Casting
	
1) Up Casting
	자식값을 부모 타입으로 형변환(자동 타입 변환)
	부모타입 참조변수 = 자식타입 객체;	
	
	부모클래스 타입의 참조변수로 자식 클래스의 객체를 가리킬수 있따.
	업 캐스팅 후에는 부모 클래스의 멤버(필드와 메소드)에만 접근할 수 있다.
	자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스의 멤버가 존재한다.
	명시적 캐스팅이 생략 가능
	
	부모클래스타입 참조변수 = (부모클래스타입) new 자식 클래스 생성자();
	부모클래스타입 참조변수 = (부모클래스타입) 자식 객체;
	부모클래스타입 참조변수 = new 자식클래스 생성자();


2) Down Casting
	이미 Up Casting 된 객체를 자식 타입으로 형변환
	※ 부모 값을 자식 타입으로 형변환시 오류 발생!!!
	※ 자식클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다.

	업 캐스팅 된 객체를 다시 자식 클래스 타입으로 변환하는 것을 의미하며
	명시적 캐스팅이 필요하다
	다운 캐스팅 후에는 자식 클래스의 멤버에 접근할 수 있다.
	잘못된 다운캐스팅(자식타임의 객체에 부모 타입의 주소값을 저장, 부모객체를 자식타입으로 변환 시도하는 것)는 ClasscastException 예외가 발생한다.

3) Casting을 사용하는 이유
	부모타입인 하나의 저장공간에 여러 자식 타입의 참조값을 업캐스팅하여 저장할 수 있따(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식 타입을 각각 받아야한다고 가정하면
	Casting이 없다면 자식 타입을 매개변수로 받는 메소드를 타입별로 각각 오버로딩하여 만들어야한다.
	(자식끼리는 타입이 다르기 때문이다)
	Casting을 활용하면 부모타입의 매개변수를 가진 하나의 메소드만 만들면 된다.
	(부모타입의 참조변수로 모든 자식 타입을 저장할 수 있기 때문이다.)

※ 주의사항
	- 업 캐스팅된 자식의 참조값을 저장했다면 자식 클래스에 오버라이딩된 기능이 실행된다.
	- 업 캐스팅으로 자식의 참조값을 저장했다면 자식 클래스에 구현한 기능들은 사용할 수 없다.
	이 경우 Down Casting 을 통해 복구하고 사용한다.

4) 다형성 
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	- 오버로딩 : 생성자, 메소드
		같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 있따
	- 오버라이딩 :상속 받은 자식 클래스의 메소드
		부모클래스에 정의된 메소드 선언부를 그대로 쓰고 구현부만 재정의하는 것

	- 참조변수의 다형성(매개변수의 다형성) : 메소드 매개변수(상속 관계에서 부모크래스 타입)
		부모 클래스 타입의 참조변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다.

5) 객체각 타입 비교
	객체명 instanceof 클래스타입
	a instanceof A : 조건식, 참 거짓 중 하나가 나오는 식
		a가 A클래스 타입이면 true
		a가 A클래스 타입이 아니면 false
	
캐스팅 특징
// 1. 같은 메소드가 부모에도 있고 자식에도 있는 경우(오버라이딩) 업캐스팅을 해도 오버라이딩 된 메소드가 실행된다.
// 2. 	메소드가 부모에는 없고 자식에서만 추가된 경우
	(부모에 존재하지 않는 멤버에 접근하려는 경우)
	자식클래스에 추가한 멤버는 부모 타입의 참조변수로는 접근할 수 없다.
	이 경우 다운 캐스팅을 해야한다


과제
부모 클래스 : Person
자식 클래스 : Student, Teacher, Employee

공통메소드 : introduce() 자식클래스에서 오버라이딩
모든 필드는 private
생성자는 이름을 갖고 있는 생성자

Person 클래스
필드 : 이름, 나이, 생년월일(8자리)
메소드 : introduce() 이름, 나이 입니다. 출력


Student 클래스
필드 : boolean stu
생성자 : 매개변수 stu도 포함
메소드추가 : study()
	이름이 공부합니다 출력
메소드 오버라이딩 : 이름은 학생입니다 출력


Teacher 클래스
필드 : x
메소드 : teach()
	이름이 가르칩니다 출력
메소드 오버라이딩 : 저는 선생님 입니다 출력

Employee 클래스
필드 : x
메소드 : work()
	업무를 처리중입니다 출력
메소드 오버라이딩 : 저의 이름은 name이고 회사원입니다 출력

Main클래스
static 메소드(printInfo())
	객체 타입에 따라 다운 캐스팅하여 전용 메소드 실행












