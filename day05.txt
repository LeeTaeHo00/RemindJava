복습 -> 형변환 -> 입력 메소드 -> 연산자1
--------------------------------------------------------------
1) JAVA 개발 배경
	1995년 공식 발표, sun 마이크로시스템사 제임스 고슬링 팀이 1991년 개발 시작
	
	목적 : 
	가전제품을 제어할 수 있는 이식성이 높은 언어 개발(이 목적으로 인해 운영체제에 영향을 받지 않게됨)
	이 후 인터넷 시대와 맞물리며 웹 프로그래밍 언어로 급부상

	특징 : 
	객체 지향 프로그래밍(OOP) 언어
	C, C++의 문법을 기반으로 개발 
	-> 포인터 제거, 메모리 자동 관리(JVM), 안전성과 이식성이 강화

	이름 유래 : Oak(오크)( 개발팀 창문에 보이는 나무였음 )라는 이름을 사용하려다가
		이미 등록되어 있는 이름이어서 JAVA(커피) 이름을 사용하게 되었따.

2) JAVA 특징
	객체지향 언어(OOP : Object Oriented Programming) ***
		모든 것이 객체로 구성됨(클래스, 객체, 상속, 다형성, 캡슐화 등)
		유지보수와 확장성이 뛰어남
		
	플랫폼 독립성(Platform Independence) ***
		JVM(Java Virtual Machine) 위에서 실행됨
		Write Once, Run AnyWhere => 한 번 작성하면 어디서든 실행 가능
		
	자동 메모리 관리(Automatic Memory Management)
		가비지 컬렉터(Garbage Collector)가 불필요한 메모리 자동 정리
		개발자가 직접 메모리를 해제할 필요가 없다. -> 메모리 누수 방지

	보안성(Security)이 뛰어나다
		JVM의 샌드박스 구조로 시스템 자원에 대한 접근을 제한할 수 있따.

	멀티쓰레드 지원(Multi-threading Support)
		하나의 프로그램 내에서 여러 작업을 동시에 처리하는 것

	풍부한 라이브러리 제공
		JRE (라이브러리가 들어있음) 만으로도 대부분의 작업을 처리 할 수 있따.
		javal.util, java.io, java.net 등 API 제공

	배우기 쉬움(Simple & Familiar)
		C/C++ 기반 문법이라 익히기 쉬움
		포인터 제거, 메모리 수동 관리 제거 -> 복잡성이 감소

	동적 로딩(Dynamic Class Loading)
		실행 시 필요한 클래스만 동적으로 로딩하여 메모리 효율적으로 사용
		프로그램의 유연성과 확장성을 향상
		
3) 프로그램 개발 순서(일반 프로그램)
a. 소스파일 작성(Source File)
	hello.java, hello.c, hello.ipynb, hello.py

b. 컴파일(Compile) : 사람이 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 변환 해주는 과정
   컴파일러(Compiler) : 컴파일을 수행하는 프로그램

=> 실행 파일 생성(.class, .exe)

c. 실행
	실행파일을 컴퓨터에서 실행하면 프로그램 동작 시작
	CPU는 기계어 명령어를 해석하고 실행함

4) 자바 프로그램 개발 순서
jvm이 운영체제와 소통
a. 컴파일 이후 바이트코드를 만들고 JVM이 실행.class는 byte코드로 만들어짐

	[Hello.jva]
		↓ javac(자바컴파일러)
	[Hello.class] 바이트코드
		↓ java (JVM이 실행)
	[실행 결과 출력]


5) JVM / JRE / JDK
(1) JVM (Java Virtual Machine) : 자바 바이트코드를 실행해주는 가상 머신
	java 프로그램이 실행되는 환경
	운영체제 마다 다른 JVM이 존재함(Windows, Mac용 등)
	역할 => 클래스 로딩, 바이트 코드 해석 및 실행, 메모리 관리 *****

(2) JRE (Java Runtime Environment)
	JVM + Java 프로그램 실행에 필요한 라이브러리/ 파일 묶음
	자바로 만들어진 프로그램을 실행하기 위해선 JRE가 필요하다.
	구성 => JVM, rt.jar(런타임클래스들), 다양한 표준 클래스 라이브러리 (ex. System 같은거)

	실행할거면 JRE까지만 실행해도됨

(3) JDK (Java Development Kit)
	Java프로그램을 개발하기 위한 도구모음
	개발자용 패키지 => 컴파일, 디버그, 실행 가능
	구성=> JRE 포함, ***컴파일러(javac), 디버거(jdb), 다양한 개발도구(jar, javadoc 등)

6) 변수 : 하나의 타입으로 하나의 값을 저장하는 저장공간
	
	자료형 변수명 = 값;
	
	목적 : 값을 재사용, 값에 의미를 부여하기 위해서, 

	RAM(Random Access Memories) : 저장공간이 메모리에 할당되면 고유한 값인 주소값이 부여됨
					값은 변경될 수 있지ㅏㄴ 중복은 되지 않는다.
					JVM에서 관리하는 RAM임, 하드웨어(컴퓨터)에서의 RAM이 아니다.

	주소값 : 메모리에 할당된 저장공간의 주소

7) 자료형(Data Type)
	정수형	byte	1byte(8bit)	-128~127
		short	2byte(16bit)	-32,768 ~ 32,767			
		int(d)	4byte(32bit)	-2,147,483,648 ~ 2,147,483,647
		long	8byte(64bit)	-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
		long 값에는 숫자 뒤에 L이나 l을 붙인다(보통 L을 권장)	
	
	실수형	double	8byte(64bit)	정밀도	소수점이하 15자리 정밀도
		float	4byte(32bit)		소수점이하 6자리 정밀도

	논리형	boolean	1byte(1bit만해도됨)	true, false
	문자형	char	2byte(유니코드이기 때문에 2byte)(16bit)	'' 로 묶은 1문자 이상(NULL 안됨)
	문자열	String	??					""로 묶은 0문자 이상(없어도 됨)

8) 출력메소드
	소괄호 안에 있는 값을 콘솔창에 출력함
	println()
	print()
	printf()

	%d	10진수
	%o	8진수
	%x	16진수
	%f	실수
	%c	문자형
	%s	문자열 논리형
	
	옵션
	%[- 0][자리수][.소수점이하 or .문자열자르기]서식문자
	System.out.printf("%.2f", 1.2222) => 1.22
--------------------------------------------------------------
1. 형변환(Type Casting)
	
1) 강제형변환 : 데이터 손실이 일어날 때
	(자료형)값

2) 자동형변환
	작은 값을 큰 저장공간에 저장할 때
	정수 + 정수 => 정수
	정수 + 실수 => 실수
	char형에서 int 형변환 가능 (유니코드)

+) 자룡형
	int
	long
	double
	float
	char
	boolean
	---------> 기본 자료형
	String => 레퍼런스타입, 클래스 타입

3) 다른 자료형 -> 문자열형 형변환
	
	

	int long double float boolean char (기본자료형, 원시 타입, Primitive Type)
	다른 자료형 -> String 자료형
	다른 자료형 + "" => 다른 자료형이 문자열로 변환

4) 문자열 자료형 -> 다른 자료형 형변환
	String(클래스 자료형, 참조 자료형, 레퍼런스타입)
	
	String -> 다른 자료형
	레퍼런스 자료형을 사용하여 형변환한다.
	int => Interger.parseInt()
	long => Long.parseLong()
	double => Double.paseDouble()
	float => Float.parseFloat()
	boolean => Boolean.parseBoolean()
	char => "문자열".charAt(int index) : 소괄호 안에는 정수형으로 0부터 싲가하는 방번혼를 1개만 작성할 수 있다.
	
	인덱스 번호 : 0으로 시작하는 배열의 방을 나타내는 번호

	모든 기본 자료형을 담고 이쓴 클래스 타입이 있고
	String을 다른 자료형으로 변환시에 이 클래스 타입의도움을 받는다.


2. 입력 메소드
1) 함수와 메소드
	공통점 : 하나의 기능을 의미하며, 이름뒤에 ()가 온다.
	
	차이점 : 사용하는 위치가 클래스 내부라면 메소드, 사용하는 위치가 클래스 외부라면 함수다.
		근데 자바는 모든 코드가 클래스 내부에서 만들어지기 때문에 메소드만 존재한다.

2) 입력 클래스(Scanner 클래스)
	입력 메소드를 사용하기 위해서는 반드시 입력 클래스를 불러와야한다
	import : 입력 클래스가 위치한 패키지가 다르기 때문에 패키지를 불러와야한다.(import java.util.Scanner;)	

	imp
	
	Scanner	sc 	= 	new Scanner(System.in); // 콘솔창에 넣어줄꺼라 System.in 을 씀
	자료형	변수	대입연산자	값
	sc.close();

ctrl + shift + o : 필요한 메소드 라이브러리 자동 임포트


3) 입력 메소드
	Scanner 클래스 내부에 입력 메소드가 만들어져 있따.
	next() 입력받은 값을 String 타입으로 돌려준다.
		(입력받은 값을 변수에 저장할 경우 String 타입의 변수를 만들어야 한다.)
		입력한 값을 띄어쓰기 와 엔터로 구분하고 분리한다.
		임시 저장공간에서 엔터를 소모하지 않는다.
		
		- 첫번째 문자열을 첫번째 next()에 담고 두번째 문자열은 두번째 next()에 담는다.
		String name1 = sc.next();
		String name2 = sc.next();
		syso(name1); // 김
		sysout(name2); // 영선

		띄어쓰기와 엔터는 아직 임시저장공간에 남아있따.

	nextLine() 입력받은 값을 String 타입으로 돌려준다.
	띄어쓰기를 호함한  한 줄 전체를 입력받는다.
	엔터 이전까지으 값을 가져온다.
	엔터를 임시 저장공간에서 소모한다.











































