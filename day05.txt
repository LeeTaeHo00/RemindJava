복습 -> 형변환 -> 입력 메소드 -> 연산자1
--------------------------------------------------------------
1) JAVA 개발 배경
	1995년 공식 발표, sun 마이크로시스템사 제임스 고슬링 팀이 1991년 개발 시작
	
	목적 : 
	가전제품을 제어할 수 있는 이식성이 높은 언어 개발(이 목적으로 인해 운영체제에 영향을 받지 않게됨)
	이 후 인터넷 시대와 맞물리며 웹 프로그래밍 언어로 급부상

	특징 : 
	객체 지향 프로그래밍(OOP) 언어
	C, C++의 문법을 기반으로 개발 
	-> 포인터 제거, 메모리 자동 관리(JVM), 안전성과 이식성이 강화

	이름 유래 : Oak(오크)( 개발팀 창문에 보이는 나무였음 )라는 이름을 사용하려다가
		이미 등록되어 있는 이름이어서 JAVA(커피) 이름을 사용하게 되었따.

2) JAVA 특징
	객체지향 언어(OOP : Object Oriented Programming) ***
		모든 것이 객체로 구성됨(클래스, 객체, 상속, 다형성, 캡슐화 등)
		유지보수와 확장성이 뛰어남
		
	플랫폼 독립성(Platform Independence) ***
		JVM(Java Virtual Machine) 위에서 실행됨
		Write Once, Run AnyWhere => 한 번 작성하면 어디서든 실행 가능
		
	자동 메모리 관리(Automatic Memory Management)
		가비지 컬렉터(Garbage Collector)가 불필요한 메모리 자동 정리
		개발자가 직접 메모리를 해제할 필요가 없다. -> 메모리 누수 방지

	보안성(Security)이 뛰어나다
		JVM의 샌드박스 구조로 시스템 자원에 대한 접근을 제한할 수 있따.

	멀티쓰레드 지원(Multi-threading Support)
		하나의 프로그램 내에서 여러 작업을 동시에 처리하는 것

	풍부한 라이브러리 제공
		JRE (라이브러리가 들어있음) 만으로도 대부분의 작업을 처리 할 수 있따.
		javal.util, java.io, java.net 등 API 제공

	배우기 쉬움(Simple & Familiar)
		C/C++ 기반 문법이라 익히기 쉬움
		포인터 제거, 메모리 수동 관리 제거 -> 복잡성이 감소

	동적 로딩(Dynamic Class Loading)
		실행 시 필요한 클래스만 동적으로 로딩하여 메모리 효율적으로 사용
		프로그램의 유연성과 확장성을 향상
		
3) 프로그램 개발 순서(일반 프로그램)
a. 소스파일 작성(Source File)
	hello.java, hello.c, hello.ipynb, hello.py

b. 컴파일(Compile) : 사람이 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 변환 해주는 과정
   컴파일러(Compiler) : 컴파일을 수행하는 프로그램

=> 실행 파일 생성(.class, .exe)

c. 실행
	실행파일을 컴퓨터에서 실행하면 프로그램 동작 시작
	CPU는 기계어 명령어를 해석하고 실행함

4) 자바 프로그램 개발 순서
jvm이 운영체제와 소통
a. 컴파일 이후 바이트코드를 만들고 JVM이 실행.class는 byte코드로 만들어짐

	[Hello.jva]
		↓ javac(자바컴파일러)
	[Hello.class] 바이트코드
		↓ java (JVM이 실행)
	[실행 결과 출력]


5) JVM / JRE / JDK
(1) JVM (Java Virtual Machine) : 자바 바이트코드를 실행해주는 가상 머신
	java 프로그램이 실행되는 환경
	운영체제 마다 다른 JVM이 존재함(Windows, Mac용 등)
	역할 => 클래스 로딩, 바이트 코드 해석 및 실행, 메모리 관리 *****

(2) JRE (Java Runtime Environment)
	JVM + Java 프로그램 실행에 필요한 라이브러리/ 파일 묶음
	자바로 만들어진 프로그램을 실행하기 위해선 JRE가 필요하다.
	구성 => JVM, rt.jar(런타임클래스들), 다양한 표준 클래스 라이브러리 (ex. System 같은거)

	실행할거면 JRE까지만 실행해도됨

(3) JDK (Java Development Kit)
	Java프로그램을 개발하기 위한 도구모음
	개발자용 패키지 => 컴파일, 디버그, 실행 가능
	구성=> JRE 포함, ***컴파일러(javac), 디버거(jdb), 다양한 개발도구(jar, javadoc 등)

6) 변수 : 하나의 타입으로 하나의 값을 저장하는 저장공간
	
	자료형 변수명 = 값;
	
	목적 : 값을 재사용, 값에 의미를 부여하기 위해서, 

	RAM(Random Access Memories) : 저장공간이 메모리에 할당되면 고유한 값인 주소값이 부여됨
					값은 변경될 수 있지ㅏㄴ 중복은 되지 않는다.
					JVM에서 관리하는 RAM임, 하드웨어(컴퓨터)에서의 RAM이 아니다.

	주소값 : 메모리에 할당된 저장공간의 주소

7) 자료형(Data Type)
	정수형	byte	1byte(8bit)	-128~127
		short	2byte(16bit)	-32,768 ~ 32,767			
		int(d)	4byte(32bit)	-2,147,483,648 ~ 2,147,483,647
		long	8byte(64bit)	-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
		long 값에는 숫자 뒤에 L이나 l을 붙인다(보통 L을 권장)	
	
	실수형	double	8byte(64bit)	정밀도	소수점이하 15자리 정밀도
		float	4byte(32bit)		소수점이하 6자리 정밀도

	논리형	boolean	1byte(1bit만해도됨)	true, false
	문자형	char	2byte(유니코드이기 때문에 2byte)(16bit)	'' 로 묶은 1문자 이상(NULL 안됨)
	문자열	String	??					""로 묶은 0문자 이상(없어도 됨)

8) 출력메소드
	소괄호 안에 있는 값을 콘솔창에 출력함
	println()
	print()
	printf()

	%d	10진수
	%o	8진수
	%x	16진수
	%f	실수
	%c	문자형
	%s	문자열 논리형
	
	옵션
	%[- 0][자리수][.소수점이하 or .문자열자르기]서식문자
	System.out.printf("%.2f", 1.2222) => 1.22
--------------------------------------------------------------
1. 형변환(Type Casting)
	
1) 강제형변환 : 데이터 손실이 일어날 때
	(자료형)값

2) 자동형변환
	작은 값을 큰 저장공간에 저장할 때
	정수 + 정수 => 정수
	정수 + 실수 => 실수
	char형에서 int 형변환 가능 (유니코드)

+) 자룡형
	int
	long
	double
	float
	char
	boolean
	---------> 기본 자료형
	String => 레퍼런스타입, 클래스 타입

3) 다른 자료형 -> 문자열형 형변환
	
	

	int long double float boolean char (기본자료형, 원시 타입, Primitive Type)
	다른 자료형 -> String 자료형
	다른 자료형 + "" => 다른 자료형이 문자열로 변환

4) 문자열 자료형 -> 다른 자료형 형변환
	String(클래스 자료형, 참조 자료형, 레퍼런스타입)
	
	String -> 다른 자료형
	레퍼런스 자료형을 사용하여 형변환한다.
	int => Interger.parseInt()
	long => Long.parseLong()
	double => Double.paseDouble()
	float => Float.parseFloat()
	boolean => Boolean.parseBoolean()
	char => "문자열".charAt(int index) : 소괄호 안에는 정수형으로 0부터 싲가하는 방번혼를 1개만 작성할 수 있다.
	
	인덱스 번호 : 0으로 시작하는 배열의 방을 나타내는 번호

	모든 기본 자료형을 담고 이쓴 클래스 타입이 있고
	String을 다른 자료형으로 변환시에 이 클래스 타입의도움을 받는다.


2. 입력 메소드
1) 함수와 메소드
	공통점 : 하나의 기능을 의미하며, 이름뒤에 ()가 온다.
	
	차이점 : 사용하는 위치가 클래스 내부라면 메소드, 사용하는 위치가 클래스 외부라면 함수다.
		근데 자바는 모든 코드가 클래스 내부에서 만들어지기 때문에 메소드만 존재한다.

2) 입력 클래스(Scanner 클래스)
	입력 메소드를 사용하기 위해서는 반드시 입력 클래스를 불러와야한다
	import : 입력 클래스가 위치한 패키지가 다르기 때문에 패키지를 불러와야한다.(import java.util.Scanner;)	

	imp
	
	Scanner	sc 	= 	new Scanner(System.in); // 콘솔창에 넣어줄꺼라 System.in 을 씀
	자료형	변수	대입연산자	값
	sc.close();

ctrl + shift + o : 필요한 메소드 라이브러리 자동 임포트


3) 입력 메소드
	Scanner 클래스 내부에 입력 메소드가 만들어져 있따.
	next() 입력받은 값을 String 타입으로 돌려준다.
		(입력받은 값을 변수에 저장할 경우 String 타입의 변수를 만들어야 한다.)
		입력한 값을 띄어쓰기 와 엔터로 구분하고 분리한다.
		임시 저장공간에서 엔터를 소모하지 않는다.
		
		- 첫번째 문자열을 첫번째 next()에 담고 두번째 문자열은 두번째 next()에 담는다.
		String name1 = sc.next();
		String name2 = sc.next();
		syso(name1); // 김
		sysout(name2); // 영선

		띄어쓰기와 엔터는 아직 임시저장공간에 남아있따.

	nextLine() 입력받은 값을 String 타입으로 돌려준다.
	띄어쓰기를 호함한  한 줄 전체를 입력받는다.
	엔터 이전까지으 값을 가져온다.
	엔터를 임시 저장공간에서 소모한다.

	.close 메소드를 사용하면 Scanner 객체를 종료하고 내부에서 사용한 자원 (메모리, 스트림 등)을 해제함

	nextInt() : 입력받은 값을 int 타입으로 돌려준다.
			입력한 값을 띄어쓰기, 엔터로 구분하고 돌려준다.

	nextDOuble() : 입력받은 값을 double 타입으로 돌려준다.
			입력한 값을 띄어쓰기, 엔터로 구분하고 돌려준다.

	위 두 next 메소드 또한 버퍼 제거하지 못한다.

3. 연산자1
1) 연산자 
	기능이 있는 특수문자

2) 연산자의 우선순위와 결합방식
	하나의 수식에 여러개의 연산자를 사용하면 어떤 연산이 먼저 되는지를 구분한다.

	최우선 (가장 높은 우선 순위를 가지고 있음) 	.(멤버접근), [](첨자 연산자), ()(메소드 호출), ++ -- 증감연산자
	단항					+, -, ++, --, ~, !, (타입)
	--이항연산자--
	산술					+, -, *, /, %
	쉬프트(비트연산)				<<, >>, >>>	
	관계					<, >, >=, <=, ==, !=
	논리					&&, ^, ||
	-----------
	삼항					조건식? 값1:값2 							오른쪽에서 왼쪽
	대입 (가장 낮은 우선 순위를 가지고 있음)		=

3) 결합성 : 하나의 수식에 동잃한 연산자가 여러개 사용되면 알맞은 방향으로 결합되어 연산되는 성질


4. 산술 연산자
	+	정수 + 정수 = 정수
		정수 + 실수 = 실수
		실수 + 실수 = 실수
		문자열 + 문자열 = 문자열 연결

	-	정수 - 정수 = 정수
		정수 - 실수 = 실수
		실수 - 실수 = 실수

	*	정수 * 정수 = 정수
		실수 * 실수 = 실수
		정수 * 실수 = 실수

	/	정수 / 정수 = 정수 (소수점 이하는 버림)
		실수 / 실수 = 실수
		정수 / 실수 = 실수
		0으로 나누면 오류

	%	정수 % 정수 = 정수
		실수 % 실수 = 실수

+) 복합대입연산자
	산술연산자와 대입연산자를 결합해서 사용한다.
	+=, -=, *=, /=, %=

	int num = 10;
	num = num + 2; // 왼쪽 nun : 저장공간, 오른쪽 : 값
	num += 2;
	위 두개는 결과는 같다
	
	num += num; 	num = num + num;

5. 증감 연산자
	++, --
	피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자
	피연산자가 1개 뿐인 단항 연산자
	증감연산자는 해당 연산자가 피연산자의 어느쪽에 위치하는가에 따라 연산의 결과가 달라지게 된다.

	전위형	: 해당 라인부터 바로 적용
		++num, --num
		
		++num 먼저 피연산자의 값을 1증가시킨 후 해당 연산을 진행한다.
		--num 먼저 피연산의 값을 1 감소 시킨 후 해당 연산을 진행한다.

		ex) 	int num = 1;
			sysout(num); // 결과 1
			sysout(++num); // 결과 2

	후위형	: 다음라인부터 적용(증감연산자가 끝난 시점부터 적용)
		num++, num--

		num++ 먼저 해당 연산을 수행하고 나서 피연산자의 값을 1 증가시킨다.
		num-- 먼저 해당 연산을 수행하고 나서 피연산자의 값을 1 감소시킨다.

		ex) 	int num = 1;
			sysout(num); // 결과 1
			sysout(num++); // 결과 1
			sysout(num); // 결과 2

	int num1 = 7, num2 = 7;
	int result1 = 0, result2 = 0;

	result1 = --num1 + 4; // --num1은 전위감소연산자 num1의 값이 먼저 감소한 뒤에 연산이 사용된다.
		// num1의 값 : 7 -> 6
		// 계산 : 6+ 4 결과값이 result1 변수에 대입, 결과10

	result2 = num2-- + 4; // num2-- 는 후위감소연산자 num2의 현재값이 연산에 사용된 후 감소된다.
		// num2의 값 : 7
		// 계산 : 7 + 4의 결과값이 result2 변수에 대입, 결과 11
		// 그 후 num2의 값 : 7 -> 6
	

컴파일에러
런타임에러


[과제 제출 기한 11시 30분 전까지 고정]
1. 코드 해석
2. 코드 작성 2문제 (로직 구성 필수)

1. 물건값과 지불금액을 입력ㅂ다아 거스름돈을 출력하기
단 거스름 돈을 1000원, 500원, 100원 짜리로 나누어 표시하세요.
클래스명 : Day05_1
입출력예시]
물건값 : 2700
지불금액 : 5000
거스름돈은 2300 원입니다.
1000원 : 2개
500원 : 0개
100원 : 3개


2. 이름과 나이를 입력 받아 내년 나이를 출력하기 (nextInt() 사용금지)
클래스명 : Day05_2
[입출력 예시]
이름 : 홍길동
나이 : 20
홍길동님의 내년 나이는 21살 입니다.
만나이는 19살 입니다.




oper 123
sctask02
sctest03
typecasting02


















