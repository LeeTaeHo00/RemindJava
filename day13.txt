복습 -> 상속 -> super -> 접근제한자

0. 복습

1) 클래스

class 클래스명{필드 : 인스턴스, 스태틱, 상수
, 메소드 : 인스턴스 메소드, 스태틱
, 생성자 : 
}

2) 생성자
	public 클래스명() {} : 기본생성자, 컴파일러가 만들어준다.
	public 클래스명(매개변수) {this.필드명 = 매개변수;}

3) this, this()
	this : 객체 자기 자신(참조값)
	this() : 자기자신의 생성자, 생성자 최상단

4) 필드와 지역변수
	지역변수 : 메소드, 생성자 블록에서 선언 (메소드와 생성자 호출시에만 생성사용) -> 스택영역
	필드 : 클래스 블록에서 선언되고 객체 내부에서 존재하고 객체 내부, 외부에서 사용가능
	
	구분	필드		지역변수
	선언위치	클래스 선언 블록	생성자, 메소드 선언블록
	존재위치	객체 내부		생성자, 메소드 호출시에만
	사용위치	객체 내,외부 	생성자, 메소드 블록 내에서만

5) 메소드
	
- 메소드드 정의
	리턴타입 메소드명(자료형 매개변수)
	{
		구현부
		실행문장
		return 리턴값;
	}

- 메소드 호출
	매개변수 리턴값	호출방식
	x	x	객체명.메소드명();
	o	x	객체명.메소드명(인수);
	x	o	sysout(객체명.메소드명());
	o	o	sysout(객체명.메소드명(인수));

- 가변길이 매개변수
	리턴타입 메소드명(자료형 ... 매개변수명)\
	{
		실행할 문장;
		return 리턴값;
	}

	메소드호출 : 매개변수의 인수값을 쉽표로 구분해서 개수와 상관없이 사용가능함
			반복문이 필요함

6) 메모리
	stack	: 매개변수, 지역변수, 메소드 실행정보가 저장되는 영역 
	heap	: new 키워드로 생성된 객체와 그객체의 인스턴스 변수가 저장되는 영역(객체마다 별도의 공간을 가짐) 가비지 컬렉터에서 메모리해제
	method	: 모든 클래스와 스태틱 멤버가 저장되는 영역(클래스로더가 클래스로딩할떄 스태틱 변수를 올려둔다), 메인메소드도 스태틱임
		  프로그램 실행동안 유지되며, 모든 객체가 공유한다.

7) 정적 블록
	static
	{
		
	}
	클래스가 로드될 때 실행되는 블록
	인스턴스가 생성되기전 한번 실행
	주로 정적 멤버 초기화 할 때 사용된다.

8) 변수 종류
	지역변수		메소드안이나 생성자 중괄호 내에서 선언되는 변수로 ***사용전 초기화*** 필수
			***메소드 실행 중***에만 유효, stack

	매개변수		메소드나 생성자 소괄호 내부에서 선언, 메소드 호출시 인수값을 전달
			기본적으로 call by value

	인스턴스 변수	클래스 중괄호 내부에서 선언되는 변수로, HEAP에 저장

			객체마다 별도로 존재, jvm이 자동으로 메모리 해제 해준다.

	정적 변수		클래스 내부에서 static 키워드가 붙은 변수로, 프로그램이 시작될 때 메모리에 할당되며 프로그램이 끝날 떄 해제된다	
			공유 변수, 클래스 단위로 관리, ***객체 없이 사용가능***, method

9) ennum 열거형
	***상수들의 집합***을 정의하는 자료형
	클래스처럼 동작하며 고정된 값들을 명확하게 표현
	***method 영역***에 저장(클래스처럼 동작)
	public static final 속성을 가짐
	***필드, 생성자, 메소드 정의 가능***함
	생성자의 접근 제한자는 private
	

-----------------------------------------------------------------------------------------------------------------------------------

1. 상속(inheritance)
	**기존 클래스의 멤버(필드, 메소드)를 재사용**하고 ***필요한 기능만 추가***하여 새로운 클래스를 만드는 방식
	여러 클래스 선언 시 멤버가 겹치는 경우, 부모 클래스를 먼저 선언하고 공통 멤버를 자식 클래스들에게
	상속해주는 개념

1) 상속문법
	clas Parents
	{
		// parents 멤버
	}

	class child extends Parents
	{
		// Parents 멤버
		// Chile 멤버
	}

	Parents : 부모클래스, 슈퍼클래스, 기반클래스, 상위클래스
	child : 자식클랫, 서브클래스, 파생클래스, 하위 클래스

	자바에서 상속은 단일 상속만 지원한다.



2) 상속사용 이유 : 공통된 멤버를 부모 클래스에 두고 자식 클래스에서 재사용하기 위해
		Tv -> 최신 tv -> 스마트 tv
		person -> student, employee, profesor
	사용이유 : 
		중복코드 제거,	
		유지보수성 향상
		객체 지향적 설계, 	





2. super, super()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자
	super : 부모의 참조값
	부모의 멤버에 접근할 때 사용
	
	super() : 부보 생성자
	자식클래스 타입의 객체로 부모 필드에 접근할 수 있다.
	우리는 객체를 만들 때 자식 생성자만 호출하기 때무에 자식 필드만 메모리에 할당된다고 생각할 수 있다.
	자식 생성자는 항상 ㅁ부모 생성자를 호출한다.
	이는 자식의 필드를 초기호 ㅏ 할때 부모 필드도 초기화하는 것을 의미한다.
	즉 자식 객체를 생성하게 되면 부모 객체도 같이 생ㅅ어되게 된다.
	부모 생성자 : this() 사용
	만약 super()를 작성하지 않아도 컴파일러가 자동으로 작성해준다.


+) this, this(), super, super()
this 현재 겍체 참조(참조값), 지역변수와 멤버 변수의 이름이 겹칠 때 구분하기 위해 사용, 현재 객체 자신을 가리킬 때 사용

this()  같은 클래스의 다른 생성자를 호출
	생성자 코드 중복을 줄이기 위해사용
	반드시 생성자 첫줄에 위치


super	부모 클래스 참조
	부모클래스의 필드/메소드에 접근할 때 사용, 오버라이딩 된 메소드를 부모 메소드로 호출 할 떄 사용
	

super() 자식클래스 생성시 부모 생성자 먼저 호출 필요할때 사용
	생략시 기본적으로  super() 가 자동으로 삽입됨
	반드시 생성자 첫줄에 위치

3. 다형성(polymorphism) : 하나의 것으로 여러 형태를 가진다.

1) 오버로딩(생성자, 메소드)
	같은 클래스 내에서 생성자 또는 메소드를 같은 이름으로 매개변수의 타입, 개수, 순서만 다르게 만든다.
	반환타입은 오버로딩에 영향을 주지 않는다.

2) 오버라이딩(메소드)
	상속관계를 맺은 자식 클래스에서 부모 클래스의 메소드를 재정의한다.
	반환타입, 메소드명 , 자료형 매개변수까지 모두 동일해야한다.
	{} 구현부의 내용만 다르게 정의한다.

+) 오버로딩과 오버라이딩의 차이
특징	오버로딩				오버라이딩
정의위치	같은 클래스내			부모클래스에 정의된 메소드 재정의(자식클래스)
선언부	이름만 같고 매개변수 타입 개수 순서 다름	부모클래스에 정의된 메소드 선언부와 완전히 일치
상속관계	필요없음				필수
사용목적	메소드의 다중정의			동작 변경(구현부 재정의)

3) 오버라이딩을 사용하는 목적
	다형성 구현	부모클래스의 참조 변수로 자식클래스의 객체를 다룰 수 있게 하기 위함
	동작 변경		부모클래스의 기본동작을 자식 클래스의 요구사항에 맞게 변경
	유지보수성 향상	공통 기능을 부모클래스에 정의하고 필요한 부분만 자식 클래스에서 변경


4. 접근 제한자(접근권한 제어자, 접근자) Access Modifier
	클래스, 필드, 생성자, 메소드에 붙여서 누가 접근할 수 있는지를 제한하는 키워드

	접근제한자		사용가능한 대상		접근허용법위
	public		클래스, 생성자, 필드, 메소드	어디서든 접근 허용
	protected	필드, 메소드		같은 패키지 + 자식클래스(다른 패키지라도)
	(default)	클래스, 생성자, 필드, 메소드	같은 패키지 안에서만 접근 가능
	private		생성자, 필드, 메소드		같은 클래스 안에서만 접근 가능

제한자		같은클래스		같은 패키지	다른피키지(상속관계X)		다른패키지(상속관계O)
public		o		o		o			o
protected	o		o		x			o
(default)	o		o		x			x
private		o		x		x			x

1) public : 모든 곳에서 접근 가능, ex) 공용 API 메소드, 유틸리티 메소드, 대표 클래스 등

2) protected : 필드, 메소드, 생성자 사용가능,     클래스 자체의 접근제어자는 public 과 default만 사용가능하고 protected는 ***상속관계***에서 접근을 제어하는 기느응ㄹ 제공하고 있으므로 클래스 자체에는 의미가 없다.

3) (default) : 주로 패키지 내부에서만 쓰이며, 같은 패키지 에서만 접근 가능, 다른 패키지에서는 상속관계와 상관없이 접근 불가

4) private : 같은 클래스 내부에서만 접근, 외부 클래스는 접근 부가능, getter setter 메소드를 통해 간접적으로 접근 허용
		캡슐화를 위해 주로 사용


















