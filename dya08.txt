day08

복습 -> 이중 for문 -> 배열 -> 이차원 배열 -> 메소드(앞부분)

0. 복습
1) 제어문 : 프로그램의 흐름을 제어하기 위해 사용
	조건문	if, switch 
	반복문	for, while, do~while
	기타제어문 break, continue

2) if문
	if(조건식) { 조건식 참일 때 실행문}
	else if(조건식) { 두번째 조건식이 참일 떄 실행문 }
	else { 모든 조건식이 부정일때 실행문 }

3) switch // boolean, 실수, long 올수 없음
	switch( 변수) 
	{
		case 봄 :
			실행문
		break;
		
		case 여름 :
			실행문
		break;
		
		default:
			실행문
		break;
	}
	
- 삼함연산자 : 조건이 하나일때, 값을 저장하거나 출력할 때
- if문 : 논리 연산자가 사용되거나 조건이 2개 이상일 때
- switcfh : 하나의 변수에 여러 값이 들어갈 수 있을 때


4) for : 범위를 알고 있을때 사용, 반복횟수가 정해져 있을때
	for(초기값; 조건식; 증감식) {실행문} : 조건식이 true 일경우 실행문을 실행한 후 증감이 이루어진 후 조건식으로 이동한 후 반복한다.
	break문이 있으면 중괄호 탈출
	
5) while : 조건을 만족하는 경우 반복해야 할 때
	// 조건식 비교대상변수 필요
	while(조건식){ 실행문, 조건을 바꿔줄 코드(비교대상변수 변경) }

6) do-while : 조건과 상관없이 무조건 1번은 실행되야 할때, 이후 조건이 만족하는지를 확인
	
	do{실행문}while(조건식);

7) break; 반복문/조건문 즉시 탈출

8) continue문 : 다음 반복으로 건너뜀


.length() = 문자열 길이 정수값으로 반환하는 메소드
플래그 변수 : (while)문 밖에서 아직 할일이 남아있을떄
-----------------------------------------------------------------------------------------------------
이중 for문
개념 : 	하나의 for문 안에 또 다른 for믄이 들어있는 구조
	반복적인 작업을 가로(행), 세로(열) 수행할 때 사용한다.
	바깥for문은 : 행
	안쪽 for문은 : 열

특징 	- 안쪽 for문에는 무조건 코드가 작성되어야 한다.
	- i와 j의 규칙 찾기
	- 바깥 for문이 한번 실행되면 안쪽 for 문은 조건이 false가 되떄 까지 게쏙 반복한다.
	- 안쪽 for문이 끝나면 바깥 for문이 다시 한번 반복되고 그때마다 안쪽 for문을 다시 시작한다.
	
	for(초기식; 조건식; 증감식)
	{
		바깥for문 실행문
		for(초기식2; 조건식2; 증감식2;)
		{
			안졲for문 실행문	
		}
	}


※ 구구단 만들기
-----------------------------------------------------------------------------------------------------
2. 배열(Array) : 저장공간의 나열
	변수 => 하나의 타입으로 하나의 값만 저장할 수 있는 저장공간
	
1) 배열을 사용하는 이유
	변수를 여러개 선언하면 이름도 여러개 생긴다. => 각 저장공간을 관리하기 불편하다.
	n칸 짜리 배열을 선언하면 저장공간이 여러개 생기고 이름은 하나로 관리할 수 있따.
	규칙성이 없는 값에 규칙성을 부여하기 위해서(index)

	변수[] 선언하면 RAM에 무작위 위치에 생성된다.
	배열[][][] 선언하면 index들의 저장공간들이 모두 붙어있따.
			하나의 타입으로 된 여러 값을 저장할 수 있는 저장공간의 나열

2) 배열의 선언
	- 배열변수를 선언 후 배열 생성 : 어떤 값을 넣은줄을 모르겠으나 몇칸을 만들지는 알때 사용
		자료형[] 배열명 = new 자료형[크기];
		ex) int[] ar1 = new int[5];	// 어떤 값이 들어지는 알 수 없지만 5칸짜리 배열을 선언

	- 배열 변수 선언과 함께 초기값 할당 : 어떤 값을 넣을 지 알 때 사용
		자료 형[] 배열명 ={값1, 값2, 값3, 값4};
		ex) int[] ar2 = {100,200,300,400};

	- 배열을 생성하지 않고 배열 변수를 초기화 : 어떤값이 들어올지 몇칸이 될지도 모를는 상황에 쓸수있다.
		자료형[] 배열명 = null;
		ex) int[] ar3 = null;

	- 배열 변수에 배열생성과 초기화
		배열명 = new 자료형[]{값1, 값2, ㄱ밧3}
		ex) ar3 = new int[]{1,2,3};

3) 배열이 저장되는 방식
	Stack 메모리
	Heap 메모리

4) *** new *** -> Heap 메모리에 할당된다(저장) *************************************************************************걍 외우셈
		  *****저장공간의 시작주소를 가져온다.

	null 주소의 초기값(어떤 주소가 들어갈지 모를 때 사용)
	자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상에서 동적 배열만 존재한다.

+) Runtime Data Area : JVM이 프로그램을 실행하는 동안 사용하는 메모리 영역
	JVM의 메모리 영역은 OS에게 할당받은 메모리
	운영체제로부터 할당 받은 메모리 공간 내에서 독자적으로 메모리를 관리하고 이를 여러 영역으로 나누어 사요한다.
	따라서 JVM의 메모리 영역은 운영체제의 메모리 영역과는 분리되어 동작된다.
	크게 5개의 영역으로 구분되며 힙영역, 스택영역, 메소드영역, 프로그램 카운터 레지스터, 네이티브 메소드 스택

5) 메모리영역
1. 힙영역(Heap) : 객체와 배열이 생성되는 메모리 공간
		new 연산자로 생성되는 객체나 배열이 할당
		동적메모리 할당을 사용하기 때문에 프로그램이 실행중에 메모리의 크기를 동적으로 조정할 수 있다.

2. 스택영역(stack area)
		메소드 호출(메소드를 사용) 시에 사용하는 메모리 공간
		메소드가 호출될 때마다 스택에 새로운 프레임이 생성되며 메소드 종료시에는 해당 프레임이 제거된
		각 쓰레드 마다 별도의 스택 영역을 가지며 동시에 여러 메소드가 호출될 수 있따.

3. 메소드영역(Method Area)
		클래스의 정보, static 변수, 상수 등이 저장되는 메모리 공간
		메소드 영역 JVM이 실행 될 때 생성, 모든 쓰레드가 공유한다.

4. 프로그램 카운터 레지스터(Program Counter Register)
		프로그램 카운터 레지스터는 현재 실행중인 명령어의 주소를 저장하는 메모리 공간
		JVM이 쓰레드를 생성할 때마다 쓰레드마다 별도의 PC Register를 가진다.

5. 네이티브 메소드 스택(Native Method Stack)
		Java Native Interface(JNI) 를 사용하여 호출되는 C/C++ 메소드의 스택 영역이다.


변수 => 고유한 주소값
자료형[] 참조변수(배열명) = new 자료형[칸수] => 저장공간을 만든다, 해당 저장공간 시작 주소값을 가져오는 역할

ArrayIndexOutOfBoundsException
RAM : Random Exes Memory
-----------------------------------------------------------------------------------------------------

5) 배열의 구조

	int[] ar 	=(대입연산자)  new int[]{1,1,1,1,1}
	스택 메모리		    Heap메모리에 젖안된 시작주소값
	정수형배열 ar 참조변수	    5칸짜리 정수형 배열을 만들고 값이 저장되어있다

	ar 이라는 배열을 선언했ㅇ르 경우 ar은 배열 객체의 주소값을 가리키는 참조 변수이다.
	배열 객체는 heap 영역에 할당되며, 배열 객체 안에는 여러개의 값이 담길 수 있다.
	따라서 ar 변수는 배열 객체의 주소값을 가리키고 해당 배열 객체 안에 여러 값을 가질 수 있다.

	[Stack]		[Heap]
	________	______________
	|__ar__|------->|_[8][1][2]__|
	참조변수		배열객체

6) 인덱스
	배열을 생성할 때 각각의 저장공간에 자동으로 붙여지는 번호
	0부터 순차적으로 증가하면서 부여된다.
	배열의 이름이 한개이기 때문에 이름만으로는 배열의 여러 저장공간에 접근할 수 없다.
	그렇기 때문에 index를 이용하여 각각의 저장공간에 접근한다.
	참조변수[index]로 사요하고 참조 변수[index]는 하나의 저장공간이기 때문에 변수처럼 사용한다.

6) length
	배열을 생성할 때 자동으로 생성되는 저장공간의 수(배열의 길이)
	배열의 길이니는 한 번 만들어지면 변동될 수 없으므로 length는 상수라고 볼 수 있따.
	참조변수.lenght로 사용한다.

7) 배열의 사용
	배열명(참조변수)[index] => 하나의 저장공간
	int [] ar = {5,1,2};
	syso(ar);	// 배열의 시작주소값(참조값)




=====================================================================
배열 문제
- 제출파일이름(_이태호)
- 담아주는 반복문, 출력 반복문 따로 작성
// homework08
//클래스 : ArayTask01
1. 100 ~1까지의 값을 배열에 넣고 출력
2. 1~10까지의 값을 배열에 넣고 총 합을 출력
3. 3명의 수학점수를 사용자에게 입력받아 배열에 저장하고 평균 점수를 출력
4. 0 1 2 3 0 1 2 3 배열에 담고 출력
5. A ~ F까지를 배열에 넣고 출력
6. A ~ F 중 C 만 제외하고 배열에 담아 출력
7. aBcDeFgH ...Z 배열에 담고 출력 (char만 사용)
8. 5개의 정수를 입력받은뒤 그 값을 배열에 담고 최대값과 최소값 출력






=====================================================================






























